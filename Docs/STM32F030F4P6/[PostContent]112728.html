"<b> Posted on November 29, 2014 at 06:45</b>  <div>   <br> working code   <br>   <br> #include "stm32f0xx.h"   <br> #include "stm32f0xx_rcc.h"   <br> #include "stm32f0xx_gpio.h"   <br> #include "stm32f0xx_usart.h"   <br> #include "stm32f0xx_i2c.h"   <br> #include &lt;stdio.h&gt;   <br>   <br> GPIO_InitTypeDef GPIO_InitStructure;   <br> USART_InitTypeDef USART_InitStructure;   <br> I2C_InitTypeDef&nbsp; I2C_InitStructure;   <br>   <br>   <br> uint8_t sec = 0;   <br> #define RTC_reg_address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp; //adress of the register within ds1307 or RTC   <br> #define RTC_address &nbsp;&nbsp;&nbsp; &nbsp;(0X77 &amp; 0x7f) &lt;&lt; 1 // Device address i.e RTC address   <br> #define mpu6050_FLAG_TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((uint32_t)0x1000)   <br> #define mpu6050_LONG_TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((uint32_t)(500 * mpu6050_FLAG_TIMEOUT))   <br>   <br> void USART_send( unsigned char data){   <br>   <br> &nbsp;&nbsp;&nbsp; while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);   <br> &nbsp;&nbsp;&nbsp; USART_SendData(USART1, data);   <br>   <br> }   <br>   <br> void USART_print(char* StringPtr){   <br>   <br> while(*StringPtr != 0x00){   <br> USART_send(*StringPtr);   <br> &nbsp;StringPtr++;}   <br>   <br> }   <br>   <br> uint8_t ReadReg(uint8_t RegAdd)   <br> {   <br> &nbsp; uint8_t mpu6050_BufferRX[2] ={0,0};   <br> &nbsp; uint8_t temp;   <br> &nbsp; uint32_t DataNum = 0;   <br> &nbsp; int mpu6050_Timeout = 0;   <br>   <br> &nbsp; /* Test on BUSY Flag */   <br> #if 1   <br> &nbsp; mpu6050_Timeout = mpu6050_LONG_TIMEOUT;   <br> &nbsp; while(I2C_GetFlagStatus(I2C2, I2C_ISR_BUSY) != RESET)   <br> &nbsp; {   <br> &nbsp;&nbsp;&nbsp; if((mpu6050_Timeout--) == 0) USART_print(" error1 ");   <br> &nbsp; }   <br> #endif   <br> &nbsp; /* Configure slave address, nbytes, reload, end mode and start or stop generation */   <br> &nbsp; I2C_TransferHandling(I2C2, RTC_address, 1, I2C_SoftEnd_Mode, I2C_Generate_Start_Write);   <br>   <br> &nbsp; /* Wait until TXIS flag is set */   <br> &nbsp; mpu6050_Timeout = mpu6050_LONG_TIMEOUT;   <br> &nbsp; while(I2C_GetFlagStatus(I2C2, I2C_ISR_TXIS) == RESET)   <br> &nbsp; {   <br> &nbsp;&nbsp;&nbsp; if((mpu6050_Timeout--) == 0) USART_print(" error2 ");   <br> &nbsp; }   <br>   <br> &nbsp; /* Send Register address */   <br> &nbsp; I2C_SendData(I2C2, (uint8_t)RegAdd);   <br>   <br> &nbsp; /* Wait until TC flag is set */   <br> &nbsp; mpu6050_Timeout = mpu6050_LONG_TIMEOUT;   <br> &nbsp; while(I2C_GetFlagStatus(I2C2, I2C_ISR_TC) == RESET)   <br> &nbsp; {   <br> &nbsp;&nbsp;&nbsp; if((mpu6050_Timeout--) == 0) USART_print(" error3 ");   <br> &nbsp; }   <br>   <br> &nbsp; /* Configure slave address, nbytes, reload, end mode and start or stop generation */   <br> &nbsp; I2C_TransferHandling(I2C2, RTC_address, 1, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);   <br>   <br> &nbsp; /* Reset local variable */   <br> &nbsp; DataNum = 0;   <br>   <br> &nbsp; /* Wait until all data are received */   <br> &nbsp; while (DataNum != 1)   <br> &nbsp; {   <br> &nbsp;&nbsp;&nbsp; /* Wait until RXNE flag is set */   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mpu6050_Timeout = mpu6050_LONG_TIMEOUT;   <br> &nbsp;&nbsp;&nbsp; while(I2C_GetFlagStatus(I2C2, I2C_ISR_RXNE) == RESET)   <br> &nbsp;&nbsp;&nbsp; {   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if((mpu6050_Timeout--) == 0) USART_print(" error4 ");   <br> &nbsp;&nbsp;&nbsp; }   <br>   <br> &nbsp;&nbsp;&nbsp; /* Read data from RXDR */   <br> &nbsp;&nbsp;&nbsp; mpu6050_BufferRX[DataNum]= I2C_ReceiveData(I2C2);   <br>   <br> &nbsp;&nbsp;&nbsp; /* Update number of received data */   <br> &nbsp;&nbsp;&nbsp; DataNum++;   <br> &nbsp; }   <br>   <br> &nbsp; /* Wait until STOPF flag is set */   <br> &nbsp; mpu6050_Timeout = mpu6050_LONG_TIMEOUT;   <br> &nbsp; while(I2C_GetFlagStatus(I2C2, I2C_ISR_STOPF) == RESET)   <br> &nbsp; {   <br> &nbsp;&nbsp;&nbsp; if((mpu6050_Timeout--) == 0) USART_print(" error5 ");   <br> &nbsp; }   <br>   <br> &nbsp; /* Clear STOPF flag */   <br> &nbsp; I2C_ClearFlag(I2C2, I2C_ICR_STOPCF);   <br>   <br>   <br> &nbsp; // !&lt; Store LM75_I2C received data   <br> &nbsp; //tmp = (uint16_t)(LM75_BufferRX[0] &lt;&lt; 8);   <br> &nbsp; //tmp |= LM75_BufferRX[0];   <br> &nbsp; temp = mpu6050_BufferRX[0];   <br> &nbsp; // return a Reg value   <br> &nbsp; return (uint8_t)temp;   <br>   <br>   <br>   <br> }   <br>   <br>   <br> uint8_t WRiteReg(uint8_t data,uint8_t RegAdd)   <br> {   <br> &nbsp; uint8_t mpu6050_BufferRX[2] ={0,0};   <br> &nbsp; uint8_t temp;   <br> &nbsp; uint32_t DataNum = 0;   <br> &nbsp; int mpu6050_Timeout = 0;   <br>   <br> &nbsp; /* Test on BUSY Flag */   <br>   <br> &nbsp; mpu6050_Timeout = mpu6050_LONG_TIMEOUT;   <br> &nbsp; while(I2C_GetFlagStatus(I2C2, I2C_ISR_BUSY) != RESET)   <br> &nbsp; {   <br> &nbsp;&nbsp;&nbsp; if((mpu6050_Timeout--) == 0) USART_print(" error1 ");   <br> &nbsp; }   <br>   <br> &nbsp; /* Send Start*/   <br> &nbsp; I2C_GenerateSTART(I2C2, ENABLE);   <br>   <br>   <br>   <br> &nbsp; /* Send Device address address of the DS1307*/   <br> &nbsp; I2C_SendData(I2C1, RTC_address);   <br>   <br>   <br> &nbsp; /* Send the address of register within device DS1307*/   <br> I2C_SendData(I2C1, (uint8_t)RegAdd);   <br> /* Wait until TC flag is set */   <br> &nbsp;mpu6050_Timeout = mpu6050_LONG_TIMEOUT;   <br> &nbsp;while(I2C_GetFlagStatus(I2C2, I2C_ISR_TC) == RESET)   <br> &nbsp;{   <br> &nbsp;&nbsp; if((mpu6050_Timeout--) == 0) USART_print(" error3 ");   <br> &nbsp;}   <br> /* Send the data to write in internal register*/   <br>   <br> &nbsp;I2C_SendData(I2C2, (uint8_t)data);   <br> &nbsp;/* Wait until TC flag is set */   <br> &nbsp; mpu6050_Timeout = mpu6050_LONG_TIMEOUT;   <br> &nbsp; while(I2C_GetFlagStatus(I2C2, I2C_ISR_TC) == RESET)   <br> &nbsp; {   <br> &nbsp;&nbsp;&nbsp; if((mpu6050_Timeout--) == 0) USART_print(" error3 ");   <br> &nbsp; }   <br>   <br>   <br> &nbsp; I2C_GenerateSTOP(I2C2, ENABLE);   <br> &nbsp;&nbsp;&nbsp;&nbsp; /*stop bit flag*/   <br> &nbsp;&nbsp;&nbsp;&nbsp; while(I2C_GetFlagStatus(I2C2, I2C_FLAG_STOPF));   <br> }   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br> void LED_init(void){   <br>   <br> &nbsp;&nbsp;&nbsp; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);   <br>   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9|GPIO_Pin_8;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;   <br> &nbsp;&nbsp;&nbsp; GPIO_Init(GPIOC, &amp;GPIO_InitStructure);   <br> }   <br>   <br> void USART_init(void){   <br>   <br> &nbsp;&nbsp;&nbsp; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);   <br> &nbsp;&nbsp;&nbsp; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);   <br> &nbsp;&nbsp;&nbsp; GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_1);   <br> &nbsp;&nbsp;&nbsp; GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_1);   <br>   <br> &nbsp;&nbsp;&nbsp; //Configure pins:&nbsp; Rx and Tx --------------------------   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Pin =&nbsp; GPIO_Pin_9 | GPIO_Pin_10;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;   <br> &nbsp;&nbsp;&nbsp; GPIO_Init(GPIOA, &amp;GPIO_InitStructure);   <br>   <br> &nbsp;&nbsp;&nbsp; USART_InitStructure.USART_BaudRate = 9600;   <br> &nbsp;&nbsp;&nbsp; USART_InitStructure.USART_WordLength = USART_WordLength_8b;   <br> &nbsp;&nbsp;&nbsp; USART_InitStructure.USART_StopBits = USART_StopBits_1;   <br> &nbsp;&nbsp;&nbsp; USART_InitStructure.USART_Parity = USART_Parity_No;   <br> &nbsp;&nbsp;&nbsp; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;   <br> &nbsp;&nbsp;&nbsp; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;   <br> &nbsp;&nbsp;&nbsp; USART_Init(USART1, &amp;USART_InitStructure);   <br>   <br> &nbsp;&nbsp;&nbsp; USART_Cmd(USART1,ENABLE);   <br> }   <br>   <br> void I2C_init(void){   <br>   <br> &nbsp;&nbsp;&nbsp; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);   <br> &nbsp;&nbsp;&nbsp; RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);   <br>   <br> &nbsp;&nbsp;&nbsp; /* Configure the I2C clock source. The clock is derived from the HSI */   <br> &nbsp; //&nbsp; RCC_I2CCLKConfig(RCC_I2C1CLK_HSI);   <br>   <br> &nbsp;&nbsp;&nbsp; GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_1);   <br> &nbsp;&nbsp;&nbsp; GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_1);   <br>   <br>   <br> &nbsp;&nbsp;&nbsp; //Configure pins: SCL and SDA ------------------   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;   <br> &nbsp;&nbsp;&nbsp; GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;   <br> &nbsp;&nbsp;&nbsp; GPIO_Init(GPIOB, &amp;GPIO_InitStructure);   <br>   <br> &nbsp;&nbsp;&nbsp; I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;   <br> &nbsp;&nbsp;&nbsp; I2C_InitStructure.I2C_DigitalFilter = 0x00;   <br> &nbsp;&nbsp;&nbsp; I2C_InitStructure.I2C_OwnAddress1 = 0x00; // MPU6050 7-bit adress = 0x68, 8-bit adress = 0xD0;   <br> &nbsp;&nbsp;&nbsp; I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;   <br> &nbsp;&nbsp;&nbsp; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;   <br> &nbsp;&nbsp;&nbsp; //I2C_InitStructure.I2C_Timing = 0xA0120227;   <br> &nbsp;&nbsp;&nbsp; I2C_InitStructure.I2C_Timing = 0x20310A0D;   <br> &nbsp;&nbsp;&nbsp; I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;   <br>   <br> &nbsp;&nbsp;&nbsp; I2C_Init(I2C2, &amp;I2C_InitStructure);   <br>   <br> &nbsp;&nbsp;&nbsp; I2C_Cmd(I2C2, ENABLE);   <br>   <br> }   <br>   <br> int main(void)   <br> {   <br>   <br> &nbsp;&nbsp;&nbsp; //&nbsp; LED_init();   <br> &nbsp;&nbsp;&nbsp; //&nbsp; USART_init();   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I2C_init();   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t data = &nbsp;&nbsp; &nbsp;(0X10 &amp; 0x7f) &lt;&lt; 1;   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i=0;   <br>   <br>   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(1)   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); // Wait for Empty   <br>   <br> &nbsp;&nbsp;&nbsp; //&nbsp; WRiteReg(data,RTC);   <br>   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sec =&nbsp; ReadReg(RTC_reg_address);   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //GPIO_SetBits(GPIOC, (GPIO_Pin_8 | GPIO_Pin_9));   <br> &nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;10000000;i++);   <br>   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*   <br>   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i=0;   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(USART_ReceiveData(USART1)=='x'){   <br>   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GPIO_SetBits(GPIOC, GPIO_Pin_8);   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;1000000;i++);   <br>   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GPIO_ResetBits(GPIOC, GPIO_Pin_8);   <br>   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;1000000;i++);   <br>   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */   <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }   <br> }  </div>   <!-- content transformation source ID: 12718:74F499D6-C293-4561-BFB5-4F1489999957 --> "
